getgenv().ScriptKey = "KEY_Day2044" --à¹ƒà¸ªà¹ˆ Key à¸‚à¸­à¸‡à¸„à¸¸à¸“à¹à¸•à¹ˆà¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µà¸„à¸µà¸¢à¹Œà¹ƒà¸«à¹‰à¸£à¸±à¸™à¸ªà¸„à¸£à¸´à¸›à¸•à¹Œà¸à¹ˆà¸­à¸™à¸™à¸¶à¸‡à¸£à¸­à¸šà¸„à¸¸à¸“à¸ˆà¸°à¹„à¸”à¹‰à¸¥à¸´à¸‡à¸à¹Œà¹„à¸›à¸«à¸² Key
getgenv().Language = "EN" --TH/EN à¸ à¸²à¸©à¸²à¹„à¸—à¸¢[TH] à¹à¸¥à¸°/and English[EN]
getgenv().Settings = {
	KillPlayer_WhenAllGeneratorsDone  = true,  -- à¸ˆà¸°à¸†à¹ˆà¸²à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¸•à¹ˆà¸­à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸£à¸²à¸‹à¹ˆà¸­à¸¡à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸›à¸±à¹ˆà¸™à¹„à¸Ÿà¸«à¸¡à¸”à¹à¸¥à¹‰à¸§
    ServerHop_WhenAllGeneratorsDone  = true,    -- à¸ˆà¸°à¸¢à¹‰à¸²à¸¢à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¹€à¸¡à¸·à¹ˆà¸­à¸‹à¹ˆà¸­à¸¡à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸›à¸±à¹ˆà¸™à¹„à¸Ÿà¸«à¸¡à¸”à¹à¸¥à¹‰à¸§
    FixDelay   = 1.5,                -- à¸«à¸™à¹ˆà¸§à¸‡à¹€à¸§à¸¥à¸²à¹ƒà¸™à¸à¸²à¸£à¸‹à¹ˆà¸­à¸¡ [à¸­à¸¢à¹ˆà¸²à¸•à¹ˆà¸³à¹€à¸à¸´à¸™à¸ˆà¸°à¹‚à¸”à¸™à¹€à¸•à¸°]
}

if getgenv()._OcyBuxHUBForSaKenS0x9 then return end
getgenv()._OcyBuxHUBForSaKenS0x9 = true
if not game:IsLoaded() then game.Loaded:Wait() end
if not game:IsLoaded() then repeat task.wait() until game:IsLoaded() end
local api = loadstring(game:HttpGet("https://raw.githubusercontent.com/SunOpenGL/5dax1/refs/heads/main/RTX_"))()
local InsertService = game:GetService("InsertService")
local ReGui = loadstring(game:HttpGet('https://raw.githubusercontent.com/depthso/Dear-ReGui/refs/heads/main/ReGui.lua'))()
local PrefabsId = "rbxassetid://" .. ReGui.PrefabsId
ReGui:Init({
	Prefabs = InsertService:LoadLocalAsset(PrefabsId)
})
ReGui:DefineTheme("Cherry", {
    TextSize = 22,
    TitleAlign = Enum.TextXAlignment.Center,
    TextDisabled = Color3.fromRGB(120, 100, 120),
    Text = Color3.fromRGB(200, 180, 200),
    FrameBg = Color3.fromRGB(25, 20, 25),
    FrameBgTransparency = 0.4,
    FrameBgActive = Color3.fromRGB(120, 100, 120),
    FrameBgTransparencyActive = 0.4,
    CheckMark = Color3.fromRGB(150, 100, 150),
    SliderGrab = Color3.fromRGB(150, 100, 150),
    ButtonsBg = Color3.fromRGB(0, 255, 120),
    CollapsingHeaderBg = Color3.fromRGB(150, 100, 150),
    CollapsingHeaderText = Color3.fromRGB(200, 180, 200),
    RadioButtonHoveredBg = Color3.fromRGB(150, 100, 150),
    WindowBg = Color3.fromRGB(35, 30, 35),
    TitleBarBg = Color3.fromRGB(35, 30, 35),
    TitleBarBgActive = Color3.fromRGB(50, 45, 50),
    Border = Color3.fromRGB(50, 45, 50),
    ResizeGrab = Color3.fromRGB(255, 0, 0),
    RegionBgTransparency = 1,
})
local Window = ReGui:Window({
    Title = "OcyBux [Forsaken] Ver.KaiTan V1.0",
    Theme = "Cherry",
    NoClose = true,
    NoResize = false,
    NoMove = false,
    NoCollapse = false,
    Size = UDim2.fromOffset(430, 280),
}):Center()
local KEY_DURATION = 8 * 60 * 60 
local KEY_FILE = "OB_KeyExpire.json"
getgenv().KeyExpireTime = nil
local KeyLabel = Window:Label({
    Text = (getgenv().Language == "TH" and "ðŸ”‘ à¸ªà¸–à¸²à¸™à¸°à¸„à¸µà¸¢à¹Œ: à¸à¸³à¸¥à¸±à¸‡à¹‚à¸«à¸¥à¸”..." or "ðŸ”‘ Key Status: Loading...")
})
getgenv().KeyLabel = KeyLabel
local function formatTimeLeft(seconds)
    local h = math.floor(seconds / 3600)
    local m = math.floor((seconds % 3600) / 60)
    local s = seconds % 60
    return string.format("%02d:%02d:%02d", h, m, s)
end
local function saveKeyExpireTime()
    if getgenv().KeyExpireTime then
        writefile(KEY_FILE, tostring(getgenv().KeyExpireTime))
    end
end
local function loadKeyExpireTime()
    if isfile(KEY_FILE) then
        local saved = tonumber(readfile(KEY_FILE))
        if saved and saved > os.time() then
            getgenv().KeyExpireTime = saved
            return true
        end
    end
    return false
end
getgenv().startKeyTimer = function()
    if not loadKeyExpireTime() then
        getgenv().KeyExpireTime = os.time() + KEY_DURATION
        saveKeyExpireTime()
    end
    task.spawn(function()
        while getgenv().KeyExpireTime do
            local now = os.time()
            local left = getgenv().KeyExpireTime - now
            if left <= 0 then
                getgenv().KeyLabel.Text = "âŒ Key Expired/à¸à¸¸à¸à¹à¸ˆà¸«à¸¡à¸”à¸­à¸²à¸¢à¸¸"
                getgenv().KeyExpireTime = nil
                delfile(KEY_FILE)
                break
            else
                local lang = getgenv().Language or "EN"
                if lang == "TH" then
                    getgenv().KeyLabel.Text = "â³ à¹€à¸§à¸¥à¸²à¸„à¸µà¸¢à¹Œà¸—à¸µà¹ˆà¹€à¸«à¸¥à¸·à¸­: " .. formatTimeLeft(left)
                else
                    getgenv().KeyLabel.Text = "â³ Key Time Left: " .. formatTimeLeft(left)
                end
            end
            task.wait(1)
        end
    end)
end
local Console = Window:Console({
    LineNumbers = true,
    AutoScroll = true,
    MaxLines = 200,
    Size = UDim2.new(1, 0, 1, 0),
    Position = UDim2.new(0, 0, 0, 0),
    RichText = true,
	ReadOnly = true
})
getgenv().ReGuiConsole = Console
-----------------------------
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local CoreGui = game:GetService("CoreGui")
local cookie = getgenv().RobloxCookie or "YOUR_COOKIE_KEY" -- à¸à¸¸à¸à¹à¸ˆà¸„à¸¸à¸à¸à¸µà¹‰à¸‚à¸­à¸™à¸°à¸ˆà¸°à¹ƒà¸ªà¹ˆà¹„à¸¡à¹ˆà¹ƒà¸ªà¹ˆà¸à¹‡à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸‚à¸­à¸‡à¸„à¸¸à¸“à¸„à¸£à¸±à¸š
local HttpService = game:GetService("HttpService")
local request = (syn and syn.request) or http_request or request or (fluxus and fluxus.request)
-----------------------------
function TeleportAutoExec()
    local scriptKey  = getgenv().ScriptKey or ""
    local language   = getgenv().Language or "EN"
    local settings   = getgenv().Settings or {}

    -- encode à¹à¸¥à¹‰à¸§ decode à¸à¸¥à¸±à¸šà¸•à¸­à¸™à¸£à¸±à¸™
    local fullCode = string.format([[
        getgenv().ScriptKey = %q
        getgenv().Language  = %q
        getgenv().Settings  = game:GetService("HttpService"):JSONDecode(%q)
        loadstring(game:HttpGet("https://github.com/SunOpenGL/5dax1/raw/refs/heads/main/1xe1d"))()
    ]],
        scriptKey,
        language,
        game:GetService("HttpService"):JSONEncode(settings)
    )

    queue_on_teleport(fullCode)
    warn("[Forsaken] TeleportAutoExec saved âœ…")
end
local function rejoinServer()
	local placeId = game.PlaceId
		local jobId = game.JobId
		task.spawn(function()
			pcall(function()
				TeleportAutoExec()
				TeleportService:TeleportToPlaceInstance(placeId, jobId, LocalPlayer)
			end)
			task.wait(3)
			TeleportAutoExec()
			TeleportService:Teleport(placeId, LocalPlayer)
		end)
	end
	CoreGui.RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
		if child.Name == "ErrorPrompt" then
			print("âš ï¸ ErrorPrompt detected â†’ Rejoining...")
			task.wait(1)
			rejoinServer()
		end
	end)
	LocalPlayer.OnTeleport:Connect(function(state)
		if state == Enum.TeleportState.Failed then
			print("âš ï¸ Teleport Failed â†’ retrying rejoin...")
			task.delay(2, rejoinServer)
		end
	end)
local function Run_AutoFix()
    print("âœ… Key Verified â†’ à¹€à¸£à¸´à¹ˆà¸¡ AutoFixGen")
    getgenv().DebugForsaken = true
    local DebugMode = false
    getgenv().LogQueue = getgenv().LogQueue or {}
    task.spawn(function()
        while task.wait(0.1) do
            if getgenv().ReGuiConsole then
                for _, v in ipairs(getgenv().LogQueue) do
                    getgenv().ReGuiConsole:AppendText(v)
                end
                table.clear(getgenv().LogQueue)
            end
        end
    end)
    local LangMap = {
        TH = {
            START_FIX = "ðŸ”§ à¹€à¸£à¸´à¹ˆà¸¡à¸‹à¹ˆà¸­à¸¡: %s à¸—à¸µà¹ˆ %s",
            DONE_FIX  = "âœ… à¸‹à¹ˆà¸­à¸¡à¹€à¸ªà¸£à¹‡à¸ˆ: %s",
            ALL_DONE  = "âš¡ à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸›à¸±à¹ˆà¸™à¹„à¸Ÿà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹€à¸ªà¸£à¹‡à¸ˆà¹à¸¥à¹‰à¸§",
            KILL      = "ðŸ’€ à¸†à¹ˆà¸²à¸•à¸±à¸§à¸¥à¸°à¸„à¸£à¸•à¸²à¸¡à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²",
            HOP       = "ðŸŒ à¸¢à¹‰à¸²à¸¢à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œ",
            STATE_SURVIVOR = "ðŸŸ¢ à¸œà¸¹à¹‰à¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸• â†’ à¹€à¸£à¸´à¹ˆà¸¡ AutoFix",
            STATE_SPECTATE = "ðŸ‘€ à¸à¸³à¸¥à¸±à¸‡ Spectate â†’ à¹„à¸¡à¹ˆà¸—à¸³à¸‡à¸²à¸™",
            STATE_KILLER   = "ðŸ”ª Killer â†’ à¹‚à¸ˆà¸¡à¸•à¸µà¸•à¸£à¸‡ à¹†",
            STATE_UNKNOWN  = "â“ à¸—à¸µà¸¡à¹„à¸¡à¹ˆà¸£à¸¹à¹‰à¸ˆà¸±à¸: %s",
            MAP_LOADED     = "ðŸ—ºï¸ à¹‚à¸«à¸¥à¸”à¹à¸œà¸™à¸—à¸µà¹ˆ: %s",
            NO_GEN         = "âš ï¸ à¹„à¸¡à¹ˆà¸¡à¸µ Generator à¹ƒà¸«à¹‰à¸‹à¹ˆà¸­à¸¡",
            SERVER_FULL    = "âš ï¸ à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¹€à¸•à¹‡à¸¡ / à¸§à¸²à¸£à¹Œà¸›à¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§ â†’ à¸¥à¸­à¸‡à¹ƒà¸«à¸¡à¹ˆ",
            SERVER_SUCCESS = "ðŸŒ à¸§à¸²à¸£à¹Œà¸›à¸ªà¸³à¹€à¸£à¹‡à¸ˆ â†’ %s",
        },
        EN = {
            START_FIX = "ðŸ”§ Started fixing: %s at %s",
            DONE_FIX  = "âœ… Done fixing: %s",
            ALL_DONE  = "âš¡ All generators are finished",
            KILL      = "ðŸ’€ Kill character as configured",
            HOP       = "ðŸŒ Hopping server",
            STATE_SURVIVOR = "ðŸŸ¢ Survivor â†’ Start AutoFix",
            STATE_SPECTATE = "ðŸ‘€ Spectating â†’ Do nothing",
            STATE_KILLER   = "ðŸ”ª Killer â†’ Direct attack",
            STATE_UNKNOWN  = "â“ Unknown team: %s",
            MAP_LOADED     = "ðŸ—ºï¸ Map Loaded: %s",
            NO_GEN         = "âš ï¸ No Generator to fix",
            SERVER_FULL    = "âš ï¸ Server full / Teleport failed â†’ Retry",
            SERVER_SUCCESS = "ðŸŒ Teleport success â†’ %s",
        }
    }
    local function T(key, ...)
        local lang = (getgenv().Language == "TH") and "TH" or "EN"
        local template = LangMap[lang][key] or key
        return string.format(template, ...)
    end
    local LoggerForsaken = {}
    function LoggerForsaken.debug(msg)
        table.insert(getgenv().LogQueue, msg)
    end
    local Network = require(ReplicatedStorage.Modules.Network)
    local Survivors = workspace.Players:WaitForChild("Survivors")
    local INVIS_ANIM2 = "75804462760596"
    local crawlAnimTrack
	--Api Serverhop by DayToDay2044
local DebugMode = false
local function setDebug(state: boolean)
    DebugMode = state
end
local Logger = {}
function Logger.debug(...)
    if DebugMode then
        warn("[DEBUG]", ...)
    end
end

if not request then
    Logger.debug("à¹„à¸¡à¹ˆà¸¡à¸µ request function à¸£à¸­à¸‡à¸£à¸±à¸š")
    return
end
local folder = "ServerLogs"
if not isfolder(folder) then makefolder(folder) end
local cacheFile = string.format("%s/JobIds_%d.json", folder, game.PlaceId)
local visitedFile = string.format("%s/Visited_%d.json", folder, game.PlaceId)
local function LoadJson(path)
    if not isfile(path) then return {} end
    local ok, data = pcall(function()
        return HttpService:JSONDecode(readfile(path))
    end)
    return ok and data or {}
end
local function SaveJson(path, data)
    local ok, err = pcall(function()
        writefile(path, HttpService:JSONEncode(data))
    end)
    if not ok then Logger.debug("SaveJson error:", err) end
end
local function Rejoin()
    Logger.debug("Random Rejoin à¹€à¸žà¸£à¸²à¸° cache/à¹‚à¸«à¸¥à¸”à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§à¸«à¸£à¸·à¸­à¸«à¸¡à¸”à¸«à¸™à¹‰à¸²à¹à¸¥à¹‰à¸§")
	TeleportAutoExec()
    TeleportService:Teleport(game.PlaceId, LocalPlayer)
end
local function GetServers(cursor)
    local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100%s")
        :format(game.PlaceId, cursor and ("&cursor=" .. cursor) or "")
    local response = request({
        Url = url,
        Method = "GET",
        Headers = {
            ["User-Agent"] = "Roblox/WinInet",
            ["Accept"] = "application/json",
            ["Referer"] = "https://www.roblox.com/games/" .. game.PlaceId,
            ["Origin"] = "https://www.roblox.com",
			--["Cookie"] = ".ROBLOSECURITY=" .. cookie
        }
    })
    if not response then
        Logger.debug("GetServers à¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§: à¹„à¸¡à¹ˆà¸¡à¸µ response")
        return nil
    end
    if response.StatusCode == 429 then
        Logger.debug("à¹€à¸ˆà¸­ 429 â†’ Rejoin")
        Rejoin()
        return nil
    end
    if response.StatusCode ~= 200 or not response.Body then
        Logger.debug("GetServers à¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§ | Status:", response.StatusCode)
        Rejoin()
        return nil
    end
    local ok, data = pcall(function()
        return HttpService:JSONDecode(response.Body)
    end)
    return ok and data or nil
end
local function CacheJobIds(cursor)
    local servers = GetServers(cursor)
    if not servers or not servers.data or #servers.data == 0 then
        Rejoin()
        return false
    end
    local jobs = {}
    for _, server in ipairs(servers.data) do
        if server.id then table.insert(jobs, server.id) end
    end
    local cache = {
        jobs = jobs,
        nextCursor = servers.nextPageCursor
    }
    SaveJson(cacheFile, cache)
    Logger.debug(("à¹‚à¸«à¸¥à¸” %d à¹€à¸‹à¸´à¸£à¹Œà¸Ÿ à¸¥à¸‡à¹„à¸Ÿà¸¥à¹Œ | nextCursor=%s"):format(#jobs, tostring(servers.nextPageCursor)))
    return true
end
local function TeleportFromCache()
    local cache = LoadJson(cacheFile)
    local visited = LoadJson(visitedFile)
    local jobs = cache.jobs or {}
    if not jobs or #jobs == 0 then
        Logger.debug("à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ cache â†’ à¹‚à¸«à¸¥à¸”à¸«à¸™à¹‰à¸²à¹à¸£à¸")
        if not CacheJobIds(nil) then return end
        cache = LoadJson(cacheFile)
        jobs = cache.jobs or {}
    end
    local filtered = {}
    for _, id in ipairs(jobs) do
        if id ~= game.JobId and not table.find(visited, id) then
            table.insert(filtered, id)
        end
    end
    if #filtered == 0 then
        if cache.nextCursor then
            Logger.debug("Cache à¸«à¸¡à¸” â†’ à¹‚à¸«à¸¥à¸”à¸«à¸™à¹‰à¸²à¸–à¸±à¸”à¹„à¸›à¸”à¹‰à¸§à¸¢ nextCursor")
            if not CacheJobIds(cache.nextCursor) then return end
            cache = LoadJson(cacheFile)
            jobs = cache.jobs or {}
            for _, id in ipairs(jobs) do
                if id ~= game.JobId and not table.find(visited, id) then
                    table.insert(filtered, id)
                end
            end
        else
            Logger.debug("à¹„à¸¡à¹ˆà¸¡à¸µ nextCursor à¹à¸¥à¹‰à¸§ â†’ Rejoin")
            Rejoin()
            return
        end
    end
    if #filtered == 0 then
        Logger.debug("à¹„à¸¡à¹ˆà¸¡à¸µà¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¹ƒà¸«à¸¡à¹ˆ â†’ Rejoin")
        Rejoin()
        return
    end
    local jobId = filtered[math.random(1, #filtered)]
    table.insert(visited, jobId)
    SaveJson(visitedFile, visited)
    Logger.debug("à¸§à¸²à¸£à¹Œà¸›à¹„à¸› JobId:", jobId)
	TeleportAutoExec()
    TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, LocalPlayer)
end
setDebug(false) -- à¸Ÿà¸±à¸‡à¸Šà¸±à¹ˆà¸™à¹€à¸›à¸´à¸”à¸›à¸´à¸” /debug.warn()
    local function playInvisAnim()
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hum = char:WaitForChild("Humanoid")
        if hum then
            local anim = Instance.new("Animation")
            anim.AnimationId = "rbxassetid://"..INVIS_ANIM2
            local track = hum:LoadAnimation(anim)
            track.Priority = Enum.AnimationPriority.Action4
            track:Play()
            track:AdjustSpeed(0)
            track:AdjustWeight(1)
            crawlAnimTrack = track
        end
    end
    local AnimMap = {
        ["rbxassetid://82691533602949"] = "Center",
        ["rbxassetid://122604262087779"] = "Left",
        ["rbxassetid://130355934640695"] = "Right",
    }
    local function getOccupiedSlots()
        local occupied = {}
        for _, survivor in ipairs(Survivors:GetChildren()) do
            if survivor ~= LocalPlayer.Character then
                local hum = survivor:FindFirstChildOfClass("Humanoid")
                if hum then
                    for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                        local animId = track.Animation and track.Animation.AnimationId
                        if animId and AnimMap[animId] then
                            occupied[AnimMap[animId]] = true
                        end
                    end
                end
            end
        end
        return occupied
    end
    local function getAllPositions(gen, hrp)
        local posFolder = gen:FindFirstChild("Positions")
        if not (posFolder and hrp) then return {} end
        local result = {}
        for _, p in ipairs(posFolder:GetChildren()) do
            if p:IsA("BasePart") then
                table.insert(result, {part = p, name = p.Name, dist = (hrp.Position - p.Position).Magnitude})
            end
        end
        table.sort(result, function(a,b) return a.dist < b.dist end)
        return result
    end
    local function getNearestGenerator()
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        local ok, mapFolder = pcall(function()
            return workspace.Map.Ingame:FindFirstChild("Map")
        end)
        if not ok or not mapFolder then return nil end
        local nearest, shortest = nil, math.huge
        for _, gen in ipairs(mapFolder:GetChildren()) do
            if gen:IsA("Model") and gen.Name == "Generator" then
                local prog = gen:FindFirstChild("Progress")
                if prog and prog.Value < 100 then
                    local positions = getAllPositions(gen, hrp)
                    if #positions > 0 then
                        local dist = positions[1].dist
                        if dist < shortest then
                            shortest, nearest = dist, gen
                        end
                    end
                end
            end
        end
        return nearest
    end
    local function teleportTo(posPart)
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp and posPart then
            hrp.CFrame = CFrame.new(posPart.Position)
        end
    end
    local function isSurvivor()
        local char = LocalPlayer.Character
        if not char then return false end
        return char.Parent == workspace.Players.Survivors
    end
    local function allGeneratorsDone()
        if not gameStarted then return false end
        if not isSurvivor() then return false end
        local ok, mapFolder = pcall(function()
            return workspace.Map.Ingame:FindFirstChild("Map")
        end)
        if not ok or not mapFolder then return false end
        for _, gen in ipairs(mapFolder:GetChildren()) do
            if gen:IsA("Model") and gen.Name == "Generator" then
                local prog = gen:FindFirstChild("Progress")
                if prog and prog.Value < 100 then
                    return false
                end
            end
        end
        return true
    end
    local currentFixing = nil
    local function tryFixGen(gen)
        if currentFixing == gen then return end
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local positions = getAllPositions(gen, hrp)
        local rem = gen:FindFirstChild("Remotes")
        local RF = rem and rem:FindFirstChild("RF")
        local RE = rem and rem:FindFirstChild("RE")
        local progress = gen:FindFirstChild("Progress")
        if not (RF and RE and progress) then return end
        for _, entry in ipairs(positions) do
            teleportTo(entry.part)
            task.wait(0.5)
            local ok, res = pcall(function() return RF:InvokeServer("enter") end)
            if ok and res == "fixing" then
                currentFixing = gen
                LoggerForsaken.debug(T("START_FIX", gen.Name, entry.part.Name))
                local loopRunning = true
                task.spawn(function()
                    while loopRunning and gen.Parent and progress.Value < 100 do
                        RE:FireServer("finishedPuzzle")
                        task.wait(getgenv().Settings.FixDelay)
                    end
                end)
                while progress.Value < 100 do
                    progress:GetPropertyChangedSignal("Value"):Wait()
                end
                loopRunning = false
                LoggerForsaken.debug(T("DONE_FIX", gen.Name))
                currentFixing = nil
                if allGeneratorsDone() then
                    LoggerForsaken.debug(T("ALL_DONE"))
                    if getgenv().Settings.KillPlayer_WhenAllGeneratorsDone then
                        LoggerForsaken.debug(T("KILL"))
                        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if hum then hum.Health = 0
					end
					if getgenv().Settings.ServerHop_WhenAllGeneratorsDone then
						LoggerForsaken.debug(T("HOP"))
						TeleportFromCache()
						end
					end
				end
                return true
            end
        end
    end
    local loopRunning = false
    local function startAutoFixLoop()
        if loopRunning then return end
        loopRunning = true
        task.spawn(function()
            while loopRunning do
                local gen = getNearestGenerator()
                if gen then
                    tryFixGen(gen)
                else
                    LoggerForsaken.debug(T("NO_GEN"))
                    task.wait(0.25)
                end
            end
        end)
    end
    local function stopAutoFixLoop() loopRunning = false end
    local function checkTeam()
        local char = LocalPlayer.Character
        if not char then return end
        local parent = char.Parent
        if parent == workspace.Players.Spectating then
            LoggerForsaken.debug(T("STATE_SPECTATE"))
            stopAutoFixLoop()
        elseif parent == workspace.Players.Survivors then
            LoggerForsaken.debug(T("STATE_SURVIVOR"))
            playInvisAnim()
            stopAutoFixLoop()
            startAutoFixLoop()
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.Died:Connect(function()
                    LoggerForsaken.debug("ðŸ’€ " .. T("STATE_SURVIVOR"))
                    stopAutoFixLoop()
                end)
            end
        elseif parent == workspace.Players.Killers then
            LoggerForsaken.debug(T("STATE_KILLER"))
            stopAutoFixLoop()
        else
            LoggerForsaken.debug(T("STATE_UNKNOWN", parent.Name))
            stopAutoFixLoop()
        end
    end
    local mapEventReceived = false
    local started = false
    local function safeStart()
        if started then return end
        started = true
        checkTeam()
    end
    Network:SetConnection("ReplicateMapCreation", "REMOTE_EVENT", function(config)
        local ok, data = pcall(require, config)
        local mapName = ok and data.DisplayName or config.Name
        LoggerForsaken.debug(T("MAP_LOADED", mapName))
        mapEventReceived = true
        task.spawn(function()
            task.wait(3)
            gameStarted = true
            safeStart()
        end)
    end)
    task.delay(2, function()
        if not mapEventReceived then safeStart() end
    end)
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        if mapEventReceived then task.wait(3) end
        checkTeam()
    end)
end
getgenv().OnKeyVerified = Run_AutoFix
