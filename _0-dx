if getgenv()._OcyBuxHUBJujutsu_ShenanigansS0x9 then return end
getgenv()._OcyBuxHUBJujutsu_ShenanigansS0x9 = true
if not game:IsLoaded() then game.Loaded:Wait() end
if not game:IsLoaded() then
	repeat task.wait() until game:IsLoaded()
end
local validatedOnce = false
local expectedUrl = "https://raw.githubusercontent.com/SunOpenGL/5dax1/refs/heads/main/_0-dx"
local realDestroy = cloneref and cloneref(Instance.new("Folder")).Destroy or Instance.Destroy
local realKick = cloneref and cloneref(game:GetService("Players").LocalPlayer).Kick or game:GetService("Players").LocalPlayer.Kick
local realShutdown = game.Shutdown
local realGetChildren = game.GetChildren
local function deepPurgeAndKick()
	local function wipe(container)
		for _, obj in ipairs(realGetChildren(container)) do
			pcall(function()
				if obj:IsA("Instance") and not obj:IsA("Player") then
					realDestroy(obj)
				end
			end)
		end
	end
	for _, serviceName in ipairs({
		"Workspace", "Lighting", "Players", "ReplicatedStorage",
		"StarterGui", "StarterPack", "StarterPlayer", "SoundService",
		"Chat", "TextChatService", "CoreGui"
	}) do
		pcall(function()
			wipe(game:GetService(serviceName))
		end)
	end
	local lp = game:GetService("Players").LocalPlayer
	local cam = workspace.CurrentCamera
	pcall(function()
		cam.CameraSubject = nil
		cam.CameraType = Enum.CameraType.Scriptable
	end)
	pcall(function()
		realKick(lp, "‚ùå Unauthorized execution. Game wiped.")
	end)
	task.delay(0.1, function()
		pcall(function()
			realShutdown(game)
		end)
	end)
end
local function validateLoaderInfo()
	if validatedOnce then return end
	local info = rawget(getgenv(), "_OcyBuxHUBJujutsu_Shenanigans0x9_DayToDay2044")
	if type(info) ~= "table" or info.url ~= expectedUrl or type(info.marker) ~= "userdata" then
		pcall(deepPurgeAndKick)
		return
	end
	validatedOnce = true
	if getgenv()._fromLoader then
		getgenv()._fromLoader.marker = nil
	end
end
validateLoaderInfo()
task.spawn(function()
	while not validatedOnce do
		task.wait(0.1)
		validateLoaderInfo()
	end
end)

loadstring(game:HttpGet("https://raw.githubusercontent.com/SUNRTX22/beekar/refs/heads/Showpopup/Showpupup"))()
if game.PlaceId ~= 9391468976 then
	getgenv().ShowPopup({
		Title = "‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏±‡∏ö‡πÅ‡∏°‡∏û‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡πà‡∏ô :(",
		Content = "‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡∏ô‡∏µ‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÅ‡∏Ñ‡πà‡πÅ‡∏°‡∏û Jujutsu Shenanigans :(\nBy DayToDay2044",
		Box_X = 450,
		Box_Y = 150,
		Delay = 5,
		Draggable = false,
		OnSmooth = 0.4,
		OffSmooth = 0.5,
		Titlepx = 22,
		Contentpx = 19
	})
	return
end
local InsertService = game:GetService("InsertService")
local ReGui = loadstring(game:HttpGet('https://raw.githubusercontent.com/depthso/Dear-ReGui/refs/heads/main/ReGui.lua'))()
local PrefabsId = "rbxassetid://" .. ReGui.PrefabsId
ReGui:Init({
	Prefabs = InsertService:LoadLocalAsset(PrefabsId)
})
ReGui:DefineTheme("Cherry", {
    TextSize = 18,
	TitleAlign = Enum.TextXAlignment.Center,
	TextDisabled = Color3.fromRGB(120, 100, 120),
	Text = Color3.fromRGB(200, 180, 200),
	FrameBg = Color3.fromRGB(25, 20, 25),
	FrameBgTransparency = 0.4,
	FrameBgActive = Color3.fromRGB(120, 100, 120),
	FrameBgTransparencyActive = 0.4,
	CheckMark = Color3.fromRGB(150, 100, 150),
	SliderGrab = Color3.fromRGB(150, 100, 150),
	ButtonsBg = Color3.fromRGB(0, 255, 120),
	CollapsingHeaderBg = Color3.fromRGB(150, 100, 150),
	CollapsingHeaderText = Color3.fromRGB(200, 180, 200),
	RadioButtonHoveredBg = Color3.fromRGB(150, 100, 150),
	WindowBg = Color3.fromRGB(35, 30, 35),
	TitleBarBg = Color3.fromRGB(35, 30, 35),
	TitleBarBgActive = Color3.fromRGB(50, 45, 50),
	Border = Color3.fromRGB(50, 45, 50),
	ResizeGrab = Color3.fromRGB(255, 0, 0),
	RegionBgTransparency = 1,
})
local Window = ReGui:Window({
	Title = "OcyBux Hub V1.0 Beta [Jujutsu Shenanigans]",
	Theme = "Cherry",
	NoClose = false,
	Size = UDim2.fromOffset(430, 350),
}):Center()
getgenv().ExistingWindow = Window
local HttpService = game:GetService("HttpService")
local configFolder = "DayToDay2044[JujuShenX]_Configs"
local lastUsedFile = configFolder .. "/last_used.txt"
if not isfolder(configFolder) then makefolder(configFolder) end
local function loadLastUsedConfigName()
	if isfile(lastUsedFile) then
		return readfile(lastUsedFile)
	end
	return "default"
end
local function saveLastUsedConfigName(name)
	writefile(lastUsedFile, name)
end
local selectedConfigName = loadLastUsedConfigName()
local configCombo
local function getConfigNames()
	local files = {"default"}
	for _, name in ipairs(listfiles(configFolder)) do
		if name:match("%.ini$") then
			local short = name:match("([^/\\]+)%.ini$")
			table.insert(files, short)
		end
	end
	table.sort(files)
	return files
end
local function autoLoadLastConfig()
	local lastUsed = loadLastUsedConfigName()
	local path = configFolder .. "/" .. lastUsed .. ".ini"
	if lastUsed == "default" then
		pcall(function()
			ReGui:LoadIni({
				MyCheckbox = true,
				MyCombo = "AAAA",
			}, false)
			writefile(path, ReGui:DumpIni(true))
		end)
	else
		if isfile(path) then
			pcall(function()
				ReGui:LoadIni(readfile(path), true)
			end)
		end
	end
	selectedConfigName = lastUsed
end
-- üîß Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- üßç‚Äç‚ôÇÔ∏è Player References
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local player = LocalPlayer
local speaker = LocalPlayer
local localCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HRP = nil
local currentChar = nil
local currentHumanoid = nil
local RagdollBackup = nil
local flyConnection = nil

-- üß© Knit Framework
local Knit = ReplicatedStorage:WaitForChild("Knit"):WaitForChild("Knit")
local ServicesFolder = Knit:WaitForChild("Services")

-- üì¶ Knit Remote Services
local BlockService = ServicesFolder:WaitForChild("BlockService")
local BlockActivate = BlockService.RE.Activated
local BlockDeactivate = BlockService.RE.Deactivated
local Reset = ServicesFolder:WaitForChild("JoinService").RE.Reset

-- ‚öôÔ∏è Global Game States (getgenv - ‡∏à‡∏≥‡∏Ñ‡πà‡∏≤‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ô)
getgenv().antiKnockbackEnabled    = getgenv().antiKnockbackEnabled or false
getgenv()._hookedRemotes          = getgenv()._hookedRemotes or {}
getgenv().currentWalkSpeed        = getgenv().currentWalkSpeed or 16
getgenv().currentJumpPower        = getgenv().currentJumpPower or 40
getgenv().lastTeleportTarget      = getgenv().lastTeleportTarget or nil
getgenv().teleportBehindEnabled   = getgenv().teleportBehindEnabled or false
getgenv().teleportMode            = getgenv().teleportMode or "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏´‡∏•‡∏±‡∏á‡∏®‡∏±‡∏ï‡∏£‡∏π"
getgenv().teleportScanRate        = getgenv().teleportScanRate or 0.05
getgenv().lockToLastEnemy         = getgenv().lockToLastEnemy or false
getgenv()._hookedHumanoidLoop     = getgenv()._hookedHumanoidLoop or nil
getgenv()._hookedPropertySignals  = getgenv()._hookedPropertySignals or {}
getgenv().vehicleflyEnabled       = false
getgenv().vehicleFlyStatus 		  = false
getgenv().vehicleflyspeed         = 1
getgenv().vehicleflyKey = Enum.KeyCode.R
getgenv().teleportToggleKey = Enum.KeyCode.X
local spinSpeed = getgenv().enemySpinSpeed or 5
local angle = (tick() * spinSpeed) % (math.pi * 2)


-- üß† Local (‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ)
local currentWalkSpeed      = getgenv().currentWalkSpeed
local currentJumpPower      = getgenv().currentJumpPower
local lastTeleportTarget    = getgenv().lastTeleportTarget
local teleportBehindEnabled = getgenv().teleportBehindEnabled
local teleportMode          = getgenv().teleportMode
local teleportToggleKey     = getgenv().teleportToggleKey
local teleportScanRate      = getgenv().teleportScanRate
local lockToLastEnemy       = getgenv().lockToLastEnemy

-- üéØ Feature Flags
local isBlocking           = false
local autoAttackEnabled    = false
local autoBlockEnabled     = false
local Aimlock              = false
local DrawingFov = Drawing.new("Circle")
DrawingFov.Visible = true
DrawingFov.Color = Color3.fromRGB(0, 255, 0)
DrawingFov.Thickness = 2
DrawingFov.Transparency = 0.6
DrawingFov.Filled = false
DrawingFov.ZIndex = 2
local wallCheckEnabled = false
local AimlockRange         = 500
local FovCheckEnabled = false
local FovAngle = 60  
local showBox = false
local showLine = false
local showHealth = false
local showDistance = false
local ESPData = {}
local antiRagdollEnabled   = false
local multiLockIndex       = 1
local multiLockDelay       = 0.3
local attackEnabled        = false
local attackMode           = "Up"
local lockEnabled          = false
local brutalLockEnabled    = false
local extraAntiConstraint  = false
local holding              = false
local lockedTarget         = nil

-- üìè Game Mechanics Config
local blockedRemotes   = {}
local ESP_SCALE 		= 2.0
local detectionRadius  = 12
local scanRate         = 0.01
local lockRange        = 1
local vehicleflyspeed  = 1

-- üö´ Ignore list (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô/‡∏≠‡πà‡∏≤‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞)
local ignoreListStrict = {
	["Stun"] = false,
	["Wakeup"] = true,
	["Knockback"] = true,
	["Block"] = true,
}

-- üß† ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏ó‡∏µ‡πà‡∏ú‡∏π‡∏Å‡∏Å‡∏±‡∏ö Service (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö Knit)
local currentService = "GojoService"
local characterServiceMap = {
	["Honored One"]         = "GojoService",
	["Vessel"]              = "ItadoriService",
	["Restless Gambler"]    = "HakariService",
	["Ten Shadows"]         = "MegumiService",
	["Perfection"]          = "MahitoService",
	["Blood Manipulator"]   = "ChosoService",
	["Switcher"]            = "TodoService",
	["Defense Attorney"]    = "HiromiService",
	["Locust Guy"]          = "LocustService",
	["Star Rage"]           = "YukiService",
}
local function getSafeHRP()
	if localCharacter then
		return localCharacter:FindFirstChild("HumanoidRootPart")
	end
end
local function isThreat(infoFolder, localName)
	for _, child in ipairs(infoFolder:GetChildren()) do
		if ignoreListStrict[child.Name] then
			if child:IsA("StringValue") and child.Value ~= localName then
				return true
			end
		elseif not ignoreListStrict[child.Name] then
			return true
		end
	end
	return false
end
local function startBlock()
	if not isBlocking then
		BlockActivate:FireServer()
		isBlocking = true
	end
end
local function stopBlock()
	if isBlocking then
		BlockDeactivate:FireServer()
		isBlocking = false
	end
end
local function autoBlockLoop()
	while true do
		if autoBlockEnabled and localCharacter then
			local HRP = getSafeHRP()
			local myName = Players.LocalPlayer.Name
			local shouldBlock = false
			for _, char in ipairs(workspace:WaitForChild("Characters"):GetChildren()) do
				if char ~= localCharacter then
					local info = char:FindFirstChild("Info")
					local enemyHRP = char:FindFirstChild("HumanoidRootPart")
					if info and enemyHRP and HRP then
						local dist = (enemyHRP.Position - HRP.Position).Magnitude
						if dist <= detectionRadius and isThreat(info, myName) then
							shouldBlock = true
							break
						end
					end
				end
			end
			if shouldBlock then
				startBlock()
			else
				stopBlock()
			end
		else
			stopBlock()
		end
		task.wait(scanRate)
	end
end
local function hookCharacter()
	localCharacter = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	HRP = localCharacter:WaitForChild("HumanoidRootPart")
end
Players.LocalPlayer.CharacterAdded:Connect(hookCharacter)
hookCharacter()
task.spawn(autoBlockLoop)
local function getRoot(char)
	return char and char:FindFirstChild("HumanoidRootPart")
end
Window:Label({Text="By DayToDay2044 "})
Combat = Window:CollapsingHeader({Title="‡∏ü‡∏±‡∏á‡∏ä‡∏±‡πà‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏™‡∏π‡πâ"})
Combat:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÇ‡∏ï‡πâ‡∏ö‡∏•‡πá‡∏≠‡∏Ñ 60% [‡∏°‡∏µ‡∏ö‡∏±‡∏Ñ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÅ‡∏Å‡πâ]",
	Value = false,
	IniFlag = "AutoBlockEnabled",
	Callback = function(self, val)
		autoBlockEnabled = val
	end
})
local function getRagdollConstraints()
	local char = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	return char:WaitForChild("RagdollConstraints")
end
Combat:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏•‡πâ‡∏°‡∏û‡∏±‡∏ö",
	Value = false,
	IniFlag = "AntiRagdollEnabled",
	Callback = function(self, val)
		antiRagdollEnabled = val
	end
})
Isthatyouobito = Combat:TreeNode({Title="‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏•‡πâ‡∏°‡∏û‡∏±‡∏ö"})
Isthatyouobito:Radiobox({
	Value = false,
	IniFlag = "ExtraAntiConstraint",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏™‡∏£‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏•‡πâ‡∏°‡∏û‡∏±‡∏ö",
	Callback = function(self, Value: boolean)
		extraAntiConstraint = Value
	end
})
Isthatyouobito:Radiobox({
	Value = getgenv().antiKnockbackEnabled,
	IniFlag = "AntiKnockbackEnabled",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô",
	Callback = function(self, Value: boolean)
		getgenv().antiKnockbackEnabled = Value
	end
})
task.spawn(function()
	while true do
		if antiRagdollEnabled then
			local char = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
			local rag = char:GetAttribute("Ragdoll")
			if rag ~= nil and rag ~= 0 then
				char:SetAttribute("Ragdoll", 0)
			end
		end
		task.wait(0.05)
	end
end)
RunService.Heartbeat:Connect(function()
	if not antiRagdollEnabled then return end
	if not extraAntiConstraint then return end
	local success, RagdollConstraints = pcall(getRagdollConstraints)
	if not success or not RagdollConstraints then return end
	for _, constraint in ipairs(RagdollConstraints:GetChildren()) do
		if constraint:IsA("BallSocketConstraint") and constraint.Enabled then
			constraint.Enabled = false
		end
	end
end)
local function cancelKnockback(character)
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local step = 0
	local conn
	conn = RunService.Stepped:Connect(function()
		if not hrp or not hrp.Parent then
			if conn then conn:Disconnect() end
			return
		end
		for _, v in ipairs(hrp:GetChildren()) do
			if v:IsA("BodyMover") or v:IsA("RocketPropulsion") or v:IsA("LinearVelocity") then
				v:Destroy()
			end
		end
		hrp.AssemblyLinearVelocity = Vector3.zero
		step += 1
		if step >= 6 then
			conn:Disconnect()
		end
	end)
end
local function shouldBlock(remoteName, serviceName, args)
	local foundSelf = false
	for _, arg in ipairs(args) do
		if typeof(arg) == "Instance" and arg == Players.LocalPlayer.Character then
			foundSelf = true
			break
		end
	end
	if not foundSelf then return false end
	for _, allowedService in pairs(characterServiceMap) do
		if serviceName == allowedService and (args[1] == "Swing" or args[1] == "Swing2") then
			return false
		end
	end
	return true
end
for _, service in ipairs(ServicesFolder:GetChildren()) do
	local reFolder = service:FindFirstChild("RE")
	if reFolder then
		for _, remote in ipairs(reFolder:GetChildren()) do
			if remote:IsA("RemoteEvent") then
				getgenv()._hookedRemotes[remote] = nil
			end
		end
	end
end
for _, service in ipairs(ServicesFolder:GetChildren()) do
	local reFolder = service:FindFirstChild("RE")
	if reFolder then
		for _, remote in ipairs(reFolder:GetChildren()) do
			if remote:IsA("RemoteEvent") and not getgenv()._hookedRemotes[remote] then
				getgenv()._hookedRemotes[remote] = true
				remote.OnClientEvent:Connect(function(...)
					local args = {...}
					if not antiRagdollEnabled or not getgenv().antiKnockbackEnabled then return end
					if shouldBlock(remote.Name, service.Name, args) then
						cancelKnockback(Players.LocalPlayer.Character)
					end
				end)
			end
		end
	end
end
if getgenv()._teleportLoop then
	task.cancel(getgenv()._teleportLoop)
	getgenv()._teleportLoop = nil
end
local teleportCheckbox = Combat:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏ß‡∏≤‡∏£‡πå‡∏õ‡πÑ‡∏õ‡∏´‡∏≤‡∏®‡∏±‡∏ï‡∏£‡∏π‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞ 12",
	Value = teleportBehindEnabled,
	IniFlag = "TeleportBehindEnabled",
	Callback = function(self, val)
		teleportBehindEnabled = val
		getgenv().teleportBehindEnabled = val
		if not val then
			lastTargetChar = nil
		end
	end
})
local Teleport = Combat:TreeNode({Title = "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏´‡∏≤‡∏®‡∏±‡∏ï‡∏£‡∏π"})
Teleport:Radiobox({
	Value = lockToLastEnemy,
	IniFlag = "LockToLastEnemy",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏ä‡πá‡∏Ñ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ô‡∏ß‡∏≤‡∏õ‡∏°‡∏±‡πà‡∏ß",
	Callback = function(self, val)
		lockToLastEnemy = val
		getgenv().lockToLastEnemy = val
		if not val then
			lastTargetChar = nil
		end
	end
})
Teleport:Combo({
	Label = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏£‡πå‡∏õ",
	Selected = teleportMode,
	IniFlag = "TeleportMode",
	Items = {
		"‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏´‡∏•‡∏±‡∏á‡∏®‡∏±‡∏ï‡∏£‡∏π",
		"‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡∏®‡∏±‡∏ï‡∏£‡∏π",
		"‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏ö‡∏ô‡∏´‡∏±‡∏ß‡∏®‡∏±‡∏ï‡∏£‡∏π",
		"‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡πÉ‡∏ï‡πâ‡∏ï‡∏µ‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π",
		"‡∏ß‡∏≤‡∏õ‡∏´‡∏°‡∏∏‡∏ô‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß‡∏®‡∏±‡∏ï‡∏£‡∏π"
	},
	Callback = function(self, val)
		teleportMode = val
		getgenv().teleportMode = val
	end
})
Teleport:SliderProgress({
	Label = "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß‡∏®‡∏±‡∏ï‡∏£‡∏π",
	Value = 5,
	Minimum = 1,
	Maximum = 50,
	IniFlag = "EnemySpinSpeed",
	Callback = function(self, val)
		getgenv().enemySpinSpeed = val
	end
})
if getgenv()._teleportKeyHook then
	getgenv()._teleportKeyHook:Disconnect()
end
getgenv()._teleportKeyHook = game:GetService("UserInputService").InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == teleportToggleKey then
		teleportBehindEnabled = not teleportBehindEnabled
		getgenv().teleportBehindEnabled = teleportBehindEnabled
		if teleportCheckbox then
			teleportCheckbox:SetValue(teleportBehindEnabled, false)
		end
	end
end)
local function getSafeHRP()
	local char = game.Players.LocalPlayer.Character
	return char and char:FindFirstChild("HumanoidRootPart")
end
local function isCharacterDead(char)
	local hum = char:FindFirstChildOfClass("Humanoid")
	return not hum or hum.Health <= 0
end
local function isDummyModel(char)
	return char.Name == "Dummy"
		and char:GetAttribute("LastM1") ~= nil
		and char:GetAttribute("M2_CD") ~= nil
		and char:GetAttribute("Ragdoll") ~= nil
end
local function forceNetworkOwner(part)
	if not part:IsA("BasePart") then return end
	if isnetworkowner(part) then return end
	pcall(function()
		sethiddenproperty(part, "NetworkOwnershipRule", Enum.NetworkOwnership.Manual)
		setnetworkowner(part, game.Players.LocalPlayer)
	end)
end
local function teleportToEnemy(enemyHRP)
	local myHRP = getSafeHRP()
	if not (myHRP and enemyHRP) then return end
	forceNetworkOwner(myHRP)
	local enemyPos = enemyHRP.Position
	local enemyLook = enemyHRP.CFrame.LookVector
	local newCFrame
	if teleportMode == "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏´‡∏•‡∏±‡∏á‡∏®‡∏±‡∏ï‡∏£‡∏π" then
		newCFrame = CFrame.new(enemyPos - enemyLook * 3, enemyPos)
	elseif teleportMode == "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡∏®‡∏±‡∏ï‡∏£‡∏π" then
		newCFrame = CFrame.new(enemyPos + enemyLook * 3, enemyPos)
	elseif teleportMode == "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏ö‡∏ô‡∏´‡∏±‡∏ß‡∏®‡∏±‡∏ï‡∏£‡∏π" then
		newCFrame = CFrame.new(enemyPos + Vector3.new(0, 4.5, 0), enemyPos)
	elseif teleportMode == "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡πÉ‡∏ï‡πâ‡∏ï‡∏µ‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π" then
		newCFrame = CFrame.new(enemyPos - Vector3.new(0, 3, 0), enemyPos)
	elseif teleportMode == "‡∏ß‡∏≤‡∏õ‡∏´‡∏°‡∏∏‡∏ô‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß‡∏®‡∏±‡∏ï‡∏£‡∏π" then
		local radius = 3
		local spinSpeed = getgenv().enemySpinSpeed or 8
		local angle = (tick() * spinSpeed) % (math.pi * 2)
		local offset = Vector3.new(math.cos(angle), 0, math.sin(angle)) * radius
		newCFrame = CFrame.new(enemyPos + offset, enemyPos)
	else
		return
	end
	myHRP.CFrame = newCFrame
	myHRP.Velocity = Vector3.zero
	myHRP.RotVelocity = Vector3.zero
	local char = game.Players.LocalPlayer.Character
	local hum = char and char:FindFirstChildOfClass("Humanoid")
	if hum then
		hum:Move(Vector3.zero, false)
		hum:ChangeState(Enum.HumanoidStateType.Physics)
		task.delay(0.1, function()
			if hum then
				hum:ChangeState(Enum.HumanoidStateType.Running)
			end
		end)
	end
end
getgenv()._teleportLoop = task.spawn(function()
	while true do
		if teleportBehindEnabled and localCharacter then
			local myHRP = getSafeHRP()
			if myHRP then
				local targetChar = nil
				if lockToLastEnemy and lastTargetChar and lastTargetChar.Parent and not isCharacterDead(lastTargetChar) then
					targetChar = lastTargetChar
				else
					local closestDist = 12
					for _, char in ipairs(workspace:WaitForChild("Characters"):GetChildren()) do
						if char ~= localCharacter and not isCharacterDead(char) and not isDummyModel(char) then
							local enemyHRP = char:FindFirstChild("HumanoidRootPart")
							if enemyHRP then
								local dist = (enemyHRP.Position - myHRP.Position).Magnitude
								if dist <= closestDist then
									closestDist = dist
									targetChar = char
								end
							end
						end
					end
					if lockToLastEnemy then
						lastTargetChar = targetChar
					end
				end
				if targetChar then
					local hrp = targetChar:FindFirstChild("HumanoidRootPart")
					if hrp then
						teleportToEnemy(hrp)
					end
				end
			end
		end
		task.wait(teleportScanRate or 0.1)
	end
end)
for _, serviceName in pairs(characterServiceMap) do
	local service = ReplicatedStorage.Knit.Knit.Services:FindFirstChild(serviceName)
	if service and service:FindFirstChild("RE") and service.RE:FindFirstChild("Activated") then
		blockedRemotes[service.RE.Activated] = true
	end
end
local function getCurrentActivatedRemote()
	local serviceName = characterServiceMap[currentService]
	if serviceName then
		local service = ReplicatedStorage.Knit.Knit.Services:FindFirstChild(serviceName)
		if service and service:FindFirstChild("RE") and service.RE:FindFirstChild("Activated") then
			return service.RE.Activated
		end
	end
	return nil
end
do
	local mt = getrawmetatable(game)
	setreadonly(mt, false)
	local oldNamecall = mt.__namecall
	mt.__namecall = newcclosure(function(self, ...)
		local args = {...}
		local method = getnamecallmethod()
		if method == "FireServer"
			and blockedRemotes[self]
			and args[1] == false
			and not (autoAttackEnabled or holding) then
			return nil
		end
		return oldNamecall(self, ...)
	end)
	setreadonly(mt, true)
end
Combat:Checkbox({
	Value = false,
	IniFlag = "AttackEnabled",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏ü‡∏±‡∏á‡∏ä‡∏±‡πà‡∏ô‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ",
	Callback = function(self, Value: boolean)
		attackEnabled = Value
	end
})
local Attack = Combat:TreeNode({Title = "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ü‡∏±‡∏á‡∏ä‡∏±‡πà‡∏ô‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ"})
Attack:Combo({
	Label = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£",
	Selected = "Honored One",
	IniFlag = "CurrentService",
	Items = {
		"Honored One", 
		"Vessel", 
		"Restless Gambler",
		"Ten Shadows",
		"Perfection",
		"Blood Manipulator",
		"Switcher",
		"Defense Attorney",
		"Locust Guy",
		"Star Rage",
	},
	Callback = function(self, value)
		currentService = value 
	end
})
Attack:Combo({
	Label = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏≤‡∏£‡πÇ‡∏à‡∏°‡∏ï‡∏µ",
	Selected = "‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏™‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô",
	IniFlag = "AttackMode",
	Items = {
		"‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏™‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô",
		"‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏Å‡∏£‡∏∞‡∏ó‡∏∑‡∏ö",
		"‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏Å‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏ó‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á"
	},
	Callback = function(self, value)
		if value == "‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏™‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô" then
			attackMode = "Up"
		elseif value == "‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏Å‡∏£‡∏∞‡∏ó‡∏∑‡∏ö" then
			attackMode = "Down"
		elseif value == "‡∏ó‡πà‡∏≤‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏Å‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏ó‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á" then
			attackMode = "Back"
		end
	end
})
task.spawn(function()
	while true do
		task.wait(0.01)
		if attackEnabled and holding then
			local remote = getCurrentActivatedRemote()
			if remote and attackMode then
				remote:FireServer(attackMode)
			end
		end
	end
end)
task.spawn(function()
	while true do
		task.wait(0.01) 
		if autoAttackEnabled and lockEnabled then
			local remote = getCurrentActivatedRemote()
			local target = lockedTarget
			if remote and target then
				local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
				local targetHRP = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
				if myHRP and targetHRP then
					local dist = (targetHRP.Position - myHRP.Position).Magnitude
					if dist <= 9 then
						local mode = (attackEnabled and attackMode) or false
						remote:FireServer(mode)
					end
				end
			end
		end
	end
end)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		holding = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		holding = false
	end
end)
Combat:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏°‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏≤‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏≠‡∏≠‡πÇ‡∏ï‡πâ",
	Value = false,
	IniFlag = "LockEnabled",
	Callback = function(self, val)
		lockEnabled = val
	end
})
local Aimtarget = Combat:TreeNode({Title = "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏°‡∏≠‡∏á‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢"})
Aimtarget:Radiobox({
	Value = false,
	IniFlag = "Aimlock",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¥‡∏°‡∏•‡πá‡∏≠‡∏Ñ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢",
	Callback = function(self, Value: boolean)
		Aimlock = Value
	end
})
Aimtarget:Radiobox({
	Value = false,
	IniFlag = "WallCheckEnabled",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏≥‡πÅ‡∏û‡∏á",
	Callback = function(self, Value: boolean)
		wallCheckEnabled = Value
	end
})
Aimtarget:Radiobox({
	Value = false,
	IniFlag = "FovCheckEnabled",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏£‡∏≠‡∏ö Fov",
	Callback = function(self, Value: boolean)
		FovCheckEnabled = Value
	end
})
Aimtarget:Radiobox({
	Value = false,
	IniFlag = "BrutalLockEnabled",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏°‡∏≠‡∏á‡πÅ‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÇ‡∏´‡∏î",
	Callback = function(self, Value: boolean)
		brutalLockEnabled = Value
	end
})
Aimtarget:Radiobox({
	Value = false,
	IniFlag = "MultiLockEnabled",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏°‡∏≠‡∏á‡∏•‡πá‡∏≠‡∏Ñ‡∏´‡∏•‡∏≤‡∏¢‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô",
	Callback = function(self, Value: boolean)
		multiLockEnabled = Value
	end
})
Aimtarget:Radiobox({
	Value = false,
	IniFlag = "AutoAttackEnabled",
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏™‡∏π‡πâ‡∏≠‡∏≠‡πÇ‡∏ï‡πâ",
	Callback = function(self, Value: boolean)
		autoAttackEnabled = Value
	end
})
Aimtarget:SliderProgress({
	Label = "‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏Å‡∏≤‡∏£‡∏°‡∏≠‡∏á‡∏•‡πá‡∏≠‡∏Ñ‡∏´‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢",
	Value = 1,
	Minimum = 1,
	Maximum = 20,
	IniFlag = "LockRange",
	Callback = function(self, val)
		lockRange = val
	end
})
Aimtarget:SliderProgress({
	Label = "‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏Å‡∏•‡πâ‡∏≠‡∏Ñ‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢",
	Value = 500,
	Minimum = 1,
	Maximum = 1000,
	IniFlag = "AimlockRange",
	Callback = function(self, val)
		AimlockRange = val
	end
})
Aimtarget:SliderProgress({
	Label = "‡∏õ‡∏£‡∏±‡∏ö‡∏≠‡∏á‡∏®‡∏≤ Fov",
	Value = 30,
	Minimum = 10,
	Maximum = 70,
	IniFlag = "FovAngle",
	Callback = function(self, val)
		FovAngle = val
	end
})
local function getClosestPlayer()
	local char = LocalPlayer.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
	local myPos = char.HumanoidRootPart.Position
	local closest, closestDist = nil, math.huge
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if hrp and humanoid and humanoid.Health > 0 then
				local dist = (hrp.Position - myPos).Magnitude
				if dist < lockRange and dist < closestDist then
					closest = player
					closestDist = dist
				end
			end
		end
	end
	return closest
end
local function getClosestAimTarget()
	local char = LocalPlayer.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
	local myPos = char.HumanoidRootPart.Position
	local closest, closestDist = nil, math.huge
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if hrp and humanoid and humanoid.Health > 0 then
				local dist = (hrp.Position - myPos).Magnitude
				if dist < (AimlockRange or 500) and dist < closestDist then
					closest = player
					closestDist = dist
				end
			end
		end
	end
	return closest
end
local function getAllTargetsInRange()
	local char = LocalPlayer.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then return {} end
	local myPos = char.HumanoidRootPart.Position
	local results = {}
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local hrp = player.Character:FindFirstChild("HumanoidRootPart")
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if hrp and humanoid and humanoid.Health > 0 then
				local dist = (hrp.Position - myPos).Magnitude
				if dist <= lockRange then
					table.insert(results, player)
				end
			end
		end
	end
	return results
end
local function isVisible(targetPart: BasePart)
	local cam = workspace.CurrentCamera
	local origin = cam.CFrame.Position
	local direction = (targetPart.Position - origin)
	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
	raycastParams.IgnoreWater = true
	local result = workspace:Raycast(origin, direction, raycastParams)
	return (not result) or result.Instance:IsDescendantOf(targetPart.Parent)
end
local function isInFov(targetPos: Vector3)
	local cam = workspace.CurrentCamera
	local camPos = cam.CFrame.Position
	local camLook = cam.CFrame.LookVector
	local dirToTarget = (targetPos - camPos).Unit
	local dot = camLook:Dot(dirToTarget)
	local angle = math.deg(math.acos(dot))
	return angle <= (FovAngle / 2)
end
task.spawn(function()
	while true do
		task.wait(multiLockDelay)
		if multiLockEnabled and lockEnabled then
			local targets = getAllTargetsInRange()
			if #targets > 0 then
				multiLockIndex += 1
				if multiLockIndex > #targets then
					multiLockIndex = 1
				end
				lockedTarget = targets[multiLockIndex]
			else
				lockedTarget = nil
			end
		end
	end
end)
RunService.RenderStepped:Connect(function()
	local char = LocalPlayer.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then
		lockedTarget = nil
		return
	end
	local hrp = char.HumanoidRootPart
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end
	if not lockEnabled then
		humanoid.AutoRotate = true
		lockedTarget = nil
		return
	end
	if not multiLockEnabled then
		lockedTarget = getClosestPlayer()
	end
	if lockedTarget and lockedTarget.Character then
		local targetHRP = lockedTarget.Character:FindFirstChild("HumanoidRootPart")
		local targetHumanoid = lockedTarget.Character:FindFirstChildOfClass("Humanoid")
		if targetHRP and targetHumanoid and targetHumanoid.Health > 0 then
			local targetPos = targetHRP.Position
			local lookY = brutalLockEnabled and targetPos.Y or hrp.Position.Y
			humanoid.AutoRotate = false
			hrp.CFrame = CFrame.lookAt(hrp.Position, Vector3.new(targetPos.X, lookY, targetPos.Z))
		else
			humanoid.AutoRotate = true
			lockedTarget = nil
		end
	else
		humanoid.AutoRotate = true
	end
end)
RunService.RenderStepped:Connect(function()
	if not Aimlock or not lockEnabled then return end
	local cam = workspace.CurrentCamera
	local char = LocalPlayer.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then return end
	local aimTarget = getClosestAimTarget()
	if aimTarget and aimTarget.Character then
		local hrp = aimTarget.Character:FindFirstChild("HumanoidRootPart")
		local humanoid = aimTarget.Character:FindFirstChildOfClass("Humanoid")
		if hrp and humanoid and humanoid.Health > 0 then
			local dist = (cam.CFrame.Position - hrp.Position).Magnitude
			if dist <= (AimlockRange or 1000) then
				if (not wallCheckEnabled or isVisible(hrp)) and (not FovCheckEnabled or isInFov(hrp.Position)) then
					cam.CFrame = CFrame.lookAt(cam.CFrame.Position, hrp.Position)
				end
			end
		end
	end
end)
RunService.RenderStepped:Connect(function()
	if not FovCheckEnabled or not lockEnabled then
		DrawingFov.Visible = false
		return
	end
	local cam = workspace.CurrentCamera
	local viewportSize = cam.ViewportSize
	local centerX, centerY = viewportSize.X / 2, viewportSize.Y / 2
	DrawingFov.Visible = true
	DrawingFov.Position = Vector2.new(centerX, centerY)
	DrawingFov.Radius = (math.tan(math.rad(FovAngle / 2)) * centerY) 
end)
FunctionESP = Window:CollapsingHeader({Title="‡∏ü‡∏±‡∏á‡∏ä‡∏±‡πà‡∏ô‡∏°‡∏≠‡∏á‡πÄ‡∏´‡πá‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô"})
FunctionESP:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏£‡∏≠‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô",
	Value = false,
	IniFlag = "ShowBox",
	Callback = function(self, val)
		showBox = val
	end
})
FunctionESP:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô",
	Value = false,
	IniFlag = "ShowLine",
	Callback = function(self, val)
		showLine = val
	end
})
FunctionESP:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏™‡∏î‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô",
	Value = false,
	IniFlag = "ShowName",
	Callback = function(self, val)
		showName = val
	end
})
FunctionESP:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏î‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô",
	Value = false,
	IniFlag = "ShowHealth",
	Callback = function(self, val)
		showHealth = val
	end
})
FunctionESP:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô",
	Value = false,
	IniFlag = "ShowDistance",
	Callback = function(self, val)
		showDistance = val
	end
})
local function createESP(player)
	if ESPData[player] then return end
	local box = Drawing.new("Square")
	box.Thickness = 1
	box.Transparency = 1
	box.Color = Color3.new(1, 1, 1)
	box.Filled = false
	local line = Drawing.new("Line")
	line.Thickness = 1
	line.Transparency = 1
	line.Color = Color3.new(1, 1, 1)
	local nameText = Drawing.new("Text")
	nameText.Size = 14
	nameText.Center = true
	nameText.Outline = true
	nameText.Color = Color3.new(1, 1, 1)
	local healthText = Drawing.new("Text")
	healthText.Size = 14
	healthText.Center = true
	healthText.Outline = true
	healthText.Color = Color3.new(0, 1, 0)
	local distanceText = Drawing.new("Text")
	distanceText.Size = 14
	distanceText.Center = true
	distanceText.Outline = true
	distanceText.Color = Color3.new(1, 1, 0)
	ESPData[player] = {
		Box = box,
		Line = line,
		Health = healthText,
		Distance = distanceText,
		Name = nameText
	}
end
local function removeESP(player)
	if ESPData[player] then
		for _, v in pairs(ESPData[player]) do
			v:Remove()
		end
		ESPData[player] = nil
	end
end
local function sanitizeName(str)
	if typeof(str) ~= "string" then return "?" end
	local cleaned = str:gsub("[^\32-\126]", "")
	if cleaned == "" then
		return "?"
	end
	return cleaned
end
Players.PlayerAdded:Connect(createESP)
Players.PlayerRemoving:Connect(removeESP)
for _, player in ipairs(Players:GetPlayers()) do
	if player ~= LocalPlayer then
		createESP(player)
	end
end
RunService.RenderStepped:Connect(function()
	for player, drawings in pairs(ESPData) do
		local char = player.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		local head = char and char:FindFirstChild("Head")
		local humanoid = char and char:FindFirstChildOfClass("Humanoid")
		if not (char and hrp and head and humanoid) then
			for _, v in pairs(drawings) do v.Visible = false end
			continue
		end
		local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)
		local rootPos, rootOnScreen = Camera:WorldToViewportPoint(hrp.Position)
		if headOnScreen and rootOnScreen then
			local boxHeight = math.abs(headPos.Y - rootPos.Y) * 2 * ESP_SCALE
			local boxWidth = boxHeight / 2
			local centerX = (headPos.X + rootPos.X) / 2
			local boxX = centerX - boxWidth / 2
			local boxY = headPos.Y
			drawings.Box.Size = Vector2.new(boxWidth, boxHeight)
			drawings.Box.Position = Vector2.new(boxX, boxY)
			drawings.Box.Visible = showBox
			drawings.Line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
			drawings.Line.To = Vector2.new(rootPos.X, rootPos.Y)
			drawings.Line.Visible = showLine
			drawings.Name.Text = sanitizeName(player.DisplayName or player.Name)
			drawings.Name.Position = Vector2.new(centerX, boxY - (20 * ESP_SCALE))
			drawings.Name.Visible = showName
			drawings.Health.Text = "HP: " .. math.floor(humanoid.Health)
			drawings.Health.Position = Vector2.new(centerX, boxY - (15 * ESP_SCALE))
			drawings.Health.Visible = showHealth
			local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
			drawings.Distance.Text = "[" .. math.floor(distance) .. "m]"
			drawings.Distance.Position = Vector2.new(centerX, rootPos.Y + (boxHeight / 2) + (5 * ESP_SCALE))
			drawings.Distance.Visible = showDistance
		else
			for _, v in pairs(drawings) do v.Visible = false end
		end
	end
end)
FunctionPlayer = Window:CollapsingHeader({Title="‡∏ü‡∏±‡∏á‡∏ä‡∏±‡πà‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô"})
function StopVFly()
	getgenv().vehicleFlyStatus = false
	local root = getRoot(speaker.Character)
	if not root then return end
	if root:FindFirstChild("vFlyVelocity") then root.vFlyVelocity:Destroy() end
	if root:FindFirstChild("vFlyGyro") then root.vFlyGyro:Destroy() end
	if flyConnection then
		flyConnection:Disconnect()
		flyConnection = nil
	end
	local humanoid = speaker.Character and speaker.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid.PlatformStand = false
	end
end
function StartVFly()
	StopVFly()
	getgenv().vehicleFlyStatus = true
	local char = speaker.Character
	if not char then return end
	local root = getRoot(char)
	if not root then return end
	local cam = workspace.CurrentCamera
	local controlModule = require(speaker:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
	local bv = Instance.new("BodyVelocity")
	bv.Name = "vFlyVelocity"
	bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
	bv.Velocity = Vector3.zero
	bv.Parent = root
	local bg = Instance.new("BodyGyro")
	bg.Name = "vFlyGyro"
	bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
	bg.P = 1000
	bg.D = 50
	bg.CFrame = cam.CFrame
	bg.Parent = root
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid.PlatformStand = true
	end
	flyConnection = RunService.RenderStepped:Connect(function()
		if not getgenv().vehicleFlyStatus then return end
		if not root or not bv or not bg then return end
		local direction = controlModule:GetMoveVector()
		local speed = getgenv().vehicleflyspeed * 50
		bg.CFrame = cam.CFrame
		bv.Velocity = Vector3.zero
		if direction.Magnitude > 0 then
			bv.Velocity = (cam.CFrame.RightVector * direction.X + cam.CFrame.LookVector * -direction.Z) * speed
		end
	end)
end
speaker.CharacterAdded:Connect(function()
	task.wait(0.25)
	if getgenv().vehicleflyEnabled then
		StartVFly()
	end
end)
local flyCheckbox = FunctionPlayer:Checkbox({
	Label = "‡πÄ‡∏õ‡∏¥‡∏î‡∏ö‡∏¥‡∏ô",
	Value = getgenv().vehicleflyEnabled,
	IniFlag = "VehicleFlyEnabled",
	Callback = function(self, val)
		getgenv().vehicleflyEnabled = val
		if val then
			StartVFly()
		else
			StopVFly()
		end
	end
})
if getgenv().flyCheckbox and typeof(getgenv().flyCheckbox.SetValue) == "function" then
	getgenv().flyCheckbox = nil
end
if getgenv()._vehicleFlyKeyHook then
	getgenv()._vehicleFlyKeyHook:Disconnect()
end
flyCheckbox:SetValue(getgenv().vehicleflyEnabled, false)
getgenv().flyCheckbox = flyCheckbox
getgenv()._vehicleFlyKeyHook = UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == getgenv().vehicleflyKey then
		local newState = not getgenv().vehicleflyEnabled
		getgenv().vehicleflyEnabled = newState
		flyCheckbox:SetValue(newState, false)
		if newState then
			StartVFly()
		else
			StopVFly()
		end
	end
end)
FunctionPlayer:SliderProgress({
	Label = "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ß‡∏¥‡πà‡∏á‡πÑ‡∏ß‡∏Å‡∏≤‡∏£‡∏ö‡∏¥‡∏ô",
	Value = 1,
	Minimum = 1,
	Maximum = 20,
	IniFlag = "VehicleFlySpeed",
	Callback = function(self, val)
		getgenv().vehicleflyspeed = val
	end
})
FunctionPlayer:SliderProgress({
	Label = "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ß‡∏¥‡πà‡∏á‡πÑ‡∏ß",
	Value = currentWalkSpeed,
	Minimum = 16,
	Maximum = 100,
	IniFlag = "WalkSpeed",
	Callback = function(self, val)
		currentWalkSpeed = val
		getgenv().currentWalkSpeed = val
		if currentHumanoid then
			currentHumanoid.WalkSpeed = val
		end
	end
})
FunctionPlayer:SliderProgress({
	Label = "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î‡∏™‡∏π‡∏á",
	Value = currentJumpPower,
	Minimum = 40,
	Maximum = 100,
	IniFlag = "JumpPower",
	Callback = function(self, val)
		currentJumpPower = val
		getgenv().currentJumpPower = val
		if currentHumanoid then
			currentHumanoid.JumpPower = val
		end
	end
})
FunctionPlayer:SmallButton({
	Text = "‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ï‡∏≤‡∏¢‡∏ó‡∏±‡∏ô‡∏ó‡∏µ",
	Callback = function(self)
		replicatesignal(game:GetService("Players").LocalPlayer.Character.Humanoid.ServerBreakJoints)
	end
})
if getgenv()._hookedHumanoidLoop then
	task.cancel(getgenv()._hookedHumanoidLoop)
	getgenv()._hookedHumanoidLoop = nil
end
for _, conn in ipairs(getgenv()._hookedPropertySignals) do
	pcall(function() conn:Disconnect() end)
end
getgenv()._hookedPropertySignals = {}
local function hookHumanoid(humanoid)
	if not humanoid or humanoid == currentHumanoid then return end
	for _, conn in ipairs(getgenv()._hookedPropertySignals) do
		pcall(function() conn:Disconnect() end)
	end
	getgenv()._hookedPropertySignals = {}
	currentHumanoid = humanoid
	humanoid.WalkSpeed = currentWalkSpeed
	humanoid.JumpPower = currentJumpPower
	table.insert(getgenv()._hookedPropertySignals, humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		if humanoid and humanoid.WalkSpeed ~= currentWalkSpeed then
			humanoid.WalkSpeed = currentWalkSpeed
		end
	end))
	table.insert(getgenv()._hookedPropertySignals, humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
		if humanoid and humanoid.JumpPower ~= currentJumpPower then
			humanoid.JumpPower = currentJumpPower
		end
	end))
end
local LocalPlayer = game:GetService("Players").LocalPlayer
LocalPlayer.CharacterAdded:Connect(function(char)
	local hum = char:WaitForChild("Humanoid")
	task.wait(0.1)
	hookHumanoid(hum)
end)
task.spawn(function()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local hum = char:WaitForChild("Humanoid")
	hookHumanoid(hum)
end)
getgenv()._hookedHumanoidLoop = task.spawn(function()
	while true do
		if currentHumanoid then
			if currentHumanoid.WalkSpeed ~= currentWalkSpeed then
				currentHumanoid.WalkSpeed = currentWalkSpeed
			end
			if currentHumanoid.JumpPower ~= currentJumpPower then
				currentHumanoid.JumpPower = currentJumpPower
			end
		end
		task.wait(0.5)
	end
end)
FunctionConfig = Window:CollapsingHeader({Title="‡∏ü‡∏±‡∏á‡∏ä‡∏±‡πà‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤"})
local function createConfigCombo()
	if configCombo then configCombo:Destroy() end
	configCombo = FunctionConfig:Combo({
		Label = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≠‡∏ô‡∏ü‡∏¥‡∏Å",
		Selected = selectedConfigName,
		GetItems = getConfigNames,
		Callback = function(self, selected)
			selectedConfigName = selected
		end
	})
end
createConfigCombo()
local RowDancer = FunctionConfig:Row()
RowDancer:Button({
	Text = "üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å",
	Callback = function()
		if selectedConfigName == "default" then
			local warnPopup = Window:PopupModal({
				Title = "‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å 'default'"
			})
			warnPopup:Label({
				Text = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≠‡∏ô‡∏ü‡∏¥‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏Å‡πà‡∏≠‡∏ô",
				TextWrapped = true
			})
			warnPopup:Button({
				Text = "‡∏ï‡∏Å‡∏•‡∏á",
				Callback = function()
					warnPopup:ClosePopup()
				end
			})
			return
		end
		local path = configFolder .. "/" .. selectedConfigName .. ".ini"
		local success = pcall(function()
			writefile(path, ReGui:DumpIni(true))
		end)
		if success then
		end
	end
})
RowDancer:Button({
	Text = "üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô",
	Callback = function()
		local configCount = 0
		for _, name in ipairs(listfiles(configFolder)) do
			if name:match("%.ini$") then
				configCount += 1
			end
		end
		if configCount >= 5 then
			local alert = Window:PopupModal({
				Title = "‚ö†Ô∏è ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏≠‡∏ô‡∏ü‡∏¥‡∏Å‡∏ñ‡∏∂‡∏á‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î"
			})
			alert:Label({
				Text = "‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≠‡∏ô‡∏ü‡∏¥‡∏Å‡πÑ‡∏î‡πâ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 5 ‡πÑ‡∏ü‡∏•‡πå\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏´‡∏°‡πà",
				TextWrapped = true
			})
			alert:Button({
				Text = "‡∏ï‡∏Å‡∏•‡∏á",
				Callback = function()
					alert:ClosePopup()
				end
			})
			return
		end
		local inputName = HttpService:GenerateGUID(false):sub(1, 8)
		local popup = Window:PopupModal({
			Title = "‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å"
		})
		local input = popup:InputText({
			Label = "‡∏ä‡∏∑‡πà‡∏≠",
			Value = inputName
		})
		local warningLabel = popup:Label({
			Text = "",
			TextWrapped = true,
			TextColor3 = Color3.fromRGB(255, 100, 100)
		})
		local buttonRow = popup:Row()
		local saveButton = buttonRow:Button({
			Text = "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å",
			Disabled = true,
			Callback = function()
				local rawName = input.Value
				local name = rawName:gsub("[^%w_]", ""):sub(1, 15)
				if name == "" then
					warningLabel.Text = "‚ùå ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"
					return
				end
				local path = configFolder .. "/" .. name .. ".ini"
				writefile(path, ReGui:DumpIni(true))
				selectedConfigName = name
				saveLastUsedConfigName(name)
				configCombo.Selected = name
				configCombo.GetItems = getConfigNames
				configCombo.Visible = false
				configCombo.Visible = true
				popup:ClosePopup()
			end
		})
		buttonRow:Button({
			Text = "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
			Callback = function()
				popup:ClosePopup()
			end
		})
			game:GetService("RunService").RenderStepped:Connect(function()
			local raw = input.Value
			local clean = raw:gsub("[^%w_]", ""):sub(1, 15)
			if raw ~= clean then
				input.Value = clean
			end
			local valid = clean:match("^[A-Za-z0-9_]+$") and #clean > 0 and #clean <= 15
			pcall(function()
				saveButton:Set({ Disabled = not valid })
			end)
			if not valid then
				warningLabel.Text = "‚ùå ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"
				warningLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
			else
				warningLabel.Text = ""
			end
		end)
	end
})
RowDancer:Button({
	Text = "üìÇ ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å",
	Callback = function()
		local path = configFolder .. "/" .. selectedConfigName .. ".ini"
		local success, result
		if selectedConfigName == "default" then
			success, result = pcall(function()
				ReGui:LoadIni({
					MyCheckbox = true,
					MyCombo = "AAAA",
				}, false)
				writefile(configFolder .. "/default.ini", ReGui:DumpIni(true))
			end)
			if success then
				saveLastUsedConfigName("default")
			end
		elseif isfile(path) then
			success, result = pcall(function()
				ReGui:LoadIni(readfile(path), true)
			end)
			if success then
				saveLastUsedConfigName(selectedConfigName)
			end
		end
	end
})
RowDancer:Button({
	Text = "üóëÔ∏è ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å",
	Callback = function()
		if selectedConfigName == "default" then
			return
		end
		local confirmPopup = Window:PopupModal({
			Title = "‡∏•‡∏ö \"" .. selectedConfigName .. "\"?"
		})
		confirmPopup:Label({
			Text = "‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏≠‡∏ô‡∏ü‡∏¥‡∏Å‡∏ô‡∏µ‡πâ?\n‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ",
			TextWrapped = true
		})
		local row = confirmPopup:Row()
		row:Button({
			Text = "‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
			Callback = function()
				confirmPopup:ClosePopup()
			end
		})
		row:Button({
			Text = "‚úÖ ‡∏•‡∏ö",
			Callback = function()
				local path = configFolder .. "/" .. selectedConfigName .. ".ini"
				if isfile(path) then
					delfile(path)
					selectedConfigName = "default"
					saveLastUsedConfigName("default")
					configCombo.Selected = selectedConfigName
					configCombo.GetItems = getConfigNames
					configCombo.Visible = false
					configCombo.Visible = true
					confirmPopup:ClosePopup()
				end
			end
		})
	end
})
FunctionConfig:Radiobox({
	Value = true,
	Label = "‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏∏‡∏î‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏° (Anti Afk)",
	Callback = function(self, Value)
		if Value then
			antiAfkConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
				local vu = game:GetService("VirtualUser")
				vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
				task.wait(1)
				vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
			end)
		else
			if antiAfkConnection then
				antiAfkConnection:Disconnect()
				antiAfkConnection = nil
			end
		end
	end
})
FunctionConfig:Button({
	Text = "‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà",
	Callback = function(self)
		local rejoinPopup = Window:PopupModal({
			Title = "‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà"
		})
		rejoinPopup:Label({
			Text = "‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà?",
			TextWrapped = true
		})
		local row = rejoinPopup:Row()
		row:Button({
			Text = "‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
			Callback = function()
				rejoinPopup:ClosePopup()
			end
		})
		row:Button({
			Text = "‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà",
			Callback = function()
				game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId)
				rejoinPopup:ClosePopup()
			end
		})
	end
})
autoLoadLastConfig()
FunctionConfig:Keybind({
	Label = "‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏µ‡∏¢‡πå‡∏•‡∏±‡∏î‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î [‡∏ß‡∏≤‡∏£‡πå‡∏õ]",
	Value = getgenv().teleportToggleKey,
	OnKeybindSet = function(self, newKey)
		teleportToggleKey = newKey
		getgenv().teleportToggleKey = newKey
	end,
	Callback = function() end
})
FunctionConfig:Keybind({
	Label = "‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏µ‡∏¢‡πå‡∏•‡∏±‡∏î‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î [‡∏ö‡∏¥‡∏ô]",
	Value = getgenv().vehicleflyKey,
	OnKeybindSet = function(self, newKey)
		getgenv().vehicleflyKey = newKey
	end,
	Callback = function() end
})
